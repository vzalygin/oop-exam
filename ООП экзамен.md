## 1. Структура программы на С++. Пример простейшей программы. Препроцессор

```
Программа на С++ складывается из команд препроцессора,блока объявления типов и констант, блока описания функций, основной функции, называемой main()
```

```
Препроцессор-компьютерная программа,которая удаляет из кода комментарии, преобразует код в соответствии с макросами и выполняет иные директивы, начинающиеся с символа «#» (такие как #include, #define, разнообразные директивы типа #pragma).
```

Пример простейшей программы на C++

```c++
   //блок команд препроцессора
   #include <iostream> 
   using namespace std 
   //блок объявления типов и констант
   #DEFINE C=10
   //блок объявления и описания функций
   void foo() {cout<<"Hello World!"}
   //основная функция main()
   int main() {
    foo();
    return 0;
   }
```

## 2. Скалярные типы данных С++. Определение констант и переменных. Примеры определений

A: Целочисленные типы
Б:

## 3. Операции над скалярными данными С++. Приоритеты операций. Примеры выражений

А: Арифметические операции

```c++
int a=5;
int b=3;
int c;
c=a+b; //8 -сложение
c=b-a; //2 - вычитание
c=a*b; //15 -умножение
c=a/b; //1 (если оба числа int то результат int, если один не int то результат float)
c=a%b; //2 - остаток от деления
```

Б: Логические операции

```c++
bool a=true;
bool b=false;
bool c=false;
bool d=(((a)&&(!b))||(c)) //true
```

<br>В: Логические поразрядные-аналогично логическим, только операции выполняются над числами в их двоичном представлении</br>
<br>Г: Обычные операции сравнения (<, >, >=, <=, ==, !=)</br>
<br>Д: Сдвиговые операции </br>

```c++
unsigned int a = 2 << 2;          // 10  на два разрядов влево = 1000 - 8
unsigned int b = 16 >> 3;         // 10000 на три разряда вправо = 10 - 2
```

<br>E: Порядковые операции </br>

```c++
int a=2;
int d= a++ ; // d=2 a=3
int c= ++a ; // d=3 a=3
```

<br>Ж: Операции присваивания</br>

```
*=, +=, -=, /=, =, %=, &=, |=, ^=, <<=, >>=
```

<br>З: Тернарный оператор</br>

```c++
int a=2;
a==2? cout<<"Da" : cout<<"No"; //Da
```

<br>Приоритет оперций в С++ такой:</br>

```
1.  ( )   [ ]   ->  ::   .
2.  ! (не)  +  -  ++  --  &(адрес)  *(указатель)  sizeof new   delete
3.  .*   ->*
4.  *   /   %
5.  +  - (бинарные)
6.   <<   >>
7.   <   <=   >   >=
8.   = =   ! =
9.   &(поразрядное и)
10.  ^(исключающее или)
11.  | (поразрядное или)
12.  &&
13.  ||
14.  ?:
15.   =   *=   /=   %=   +=   -=   &=   ^=   |=   <<=   >>=
16.  ,
```

## 4. Управляющие операторы if и switch С++. Примеры

Сказать нечего, лучше привести пример)

```c++
if(a>b) coat<<a;
else cout<<b;
```

```c++
switch (n):
{
case 1: printf("Hello");
case 2: printf("World!");
default: printf("Saucesamba"); //выбор по умолчанию
}
```

## 5. Организация циклов в С++. Примеры

Цикл перебора:

```c++
int k=0;
for(int i=0;i<5;i++){
    k+=i;
}
```

Цикл while(пока):

```c++
int k=0;
while (k<5){
    k++;
}
```

Цикл do-while:

```c++
int k=6;
do{
k--;
}while(k>0)
```

## 6. Неструктурные операторы передачи управления в С++

Да-да, те самые, которыми нельзя пользоваться)

```c++
if (!b){
goto exit; 
}
else{
     /*...*/ 
}
exit: c="Error";
```

В данном примере при x>7 будет проигнорировано все что стоит после оператора continue, и будет осуществлен переход к следующей итерации цикла

```c++
while ( i < 5 )
{
    cin>>x;
    if ( x >7 ){
        cout<<"Too big number";
        continue;
    }
    y += x * x;
}
```

```c++
for(int i=0; i<n; i++)
{
    cin>>x;
    if ( x >15 )
         break;
    else y += x * x;
}
```

## 7. Указатели и ссылки. Примеры объявлений

```
Указатель- переменная, в которой хранится адресс ячейки памяти.
```

```
Ссылка тоже физически представляет собой адрес, но в отличие от указателя при работе со ссылками не используется операция разыменования.
```

Примеры:

```c++
int a,*ptri,*ptrj; 
void *b;
ptri = &a; //записали в указатель ссылку на а     
ptri = nullptr; // нулевой указатель
ptri = ptrj; //присваивание указателей
b = &a; //неявное преобразование указателю без типа к типу int
//явное преобразование типа указателя
ptri = (int *) b; //С-style
ptri = static_cast<int *> b; //C++ - style
//разыменование указателя
int c, a = 5, *ptri = &a;  
c = *ptri; 
*ptri=125;
```

## 8. Управление динамической памятью С++. Примеры

```c++
int *k;
  k = new int; //операция выделения памяти
  *k = 85;

int *a;   
  if ((a = new int(-244)) == NULL){ 
    printf("Not enough memory.");
         exit(1);  } 
  delete a; //операция освобождения памяти

//пример со списком
int *list;   
 list = new int [3]; //выделение памяти сразу на 3 объекта типа int
 *list=-244;
 *(list+1)=15;   
 *(list+2)=-45; 
 delete[] list; 
```

## 9. Адресная арифметика С++. Примеры

надо вставить фотку с презы 2 слайд 5

## 10. Массивы С++. Примеры объявлений и две технологии обработки. Пример

```c++
int mas[5]={1,2,3,4,5}; //заполнение массива при объявлении
int arr[100];  //массив
int mtr[3][5]; //матрица
```

### Технологии обработки массива

<br> Обработка массива циклом foreah</br>

```c++
int arr[5] = {1, 2, 3, 4, 5}; 
for(int &x : arr) { //работа ведется непосредственно с элементами массива
    x*= 2; 
} 
for(auto x:arr)  //работа ведётся с копиями элементов, при этом слово auto говорит нам что тип элементов определяется автоматически.
    cout << x << ' '; 

for(const auto &x:arr) //слово const говорит о том, что значения нельзя изменять 
    cout << x << ' ';
```

<br> Обработка массива с помощью адресной ариметики</br>

```c++
int *list;
(list+1) // ~ &list[1]
*(list+2) // ~ list[2]
```

## 11. Строки С++. Стандартные функции, работающие со строками. Примеры

<br>
Строка-массив символов типа char, концом которой служит символ \0.
Примеры объявления строк:
</br>

```c++
char mystr[10]; //компилятор выделит заданное кол-во памяти, не включая памяти для символа конца строки 
char str[]="hello"; //компилятор автоматически выделит нужное кол-во памяти для размещения строки + символа конца строки.
```

```c++
char *string = new char[12]; //выделяется блок памяти заданного размера.
strcpy(string, "hello"); //копируем строку в нашу переменную
delete[] string; //очищение памяти
```

```
Я думаю, что неплохо было бы знать некоторые основные функцции по типу: 
strcat (конкатенация строк)
strcmp (сравнение строк)
strcpy(копирование строк)
```

## 12. Структурный тип С++. Пример

Структура-способо организации данных, при котором данные разных типов могут храниться как одно целое.

```c
//С-style
struct prepod {
    char name[7];
    int year;
}
```

```c++
//С++ - style
typedef struct {
    char name[7];
    int year;
} prepod;
```

```c++
//Обращение к полям структуры происходит с помощью точечной нотации, то есть:
prepod.old;
prepod[i].old; 
prepod->old; //в данном случае структура-это элемент связанного списка.
```

## 13. Функции С++. Передача параметров и возвращение результатов. Примеры

Функции служат для упрощения кода, путем выделения часто используемых кусков кода в отдельные подпрограммы.
Они повышают читаемость кода, а также в некоторых случаев требуют меньше памяти и времени выполнения, чем монолитный код.

<br> Примеры передачи параметров</br>

```c++
void foo(int a) //происходит передача копии значения переменной, что требует большего кол-ва памяти.
void foo(int &a) //происходит передача непосредественно самой переменной, значение которой можно изменять.
void foo(int *a) // передаём указатель на переменную
int foo(const &a) //передача по ссылке неизменяемого значения
```

```
Для того чтобы вернуть значение из функции, можно либо передавать в нее значение по ссылке или по указателю, тогда работа будет вестись непосредственно с переменной, либо использовать служебное слово return (при этом тип возвращаемого значения должен совпадать с типом функции).
```

## 14. Параметры-массивы. Пример

<br>
Какие-то кринж вопросы с этой передачей в функцию...
</br>

```
В С++ отсутствует контроль размера массива по первому
индексу
```

При передаче массива в функцию, компилятор передает указатель
на первый элемент массива. Таким образом, функция может
получить доступ к элементам массива, используя указатель и
индексацию.
Для передачи одномерного массива в функцию, необходимо
указать имя массива в качестве параметра функции

```c++
void print_array(int arr[], int size) {
for (int i = 0; i < size; i++) {
std::cout << arr[i] << " "; }
}
```

Чтобы передать многомерный массив в функцию, необходимо
указать количество строк и столбцов в массиве, а также
указатель на первый элемент массива. Например:

```c++
void print_matrix(int (*matrix)[3], int rows) {
for (int i = 0; i < rows; i++) {
for (int j = 0; j < 3; j++) {
std::cout << matrix[i][j] << " ";
}
std::cout << std::endl;
}
}
```

## 15. Параметры-строки. Пример

Для более безопасной работы функции получающие
параметры типа «строка» целесообразно писать как
процедуры-функции.

```c++
char *strdel(const char *source,char *result)
{ char *ptr;
strcpy (result, source);
while ((ptr=strstr(result, " "))!=NULL)
strcpy(ptr,ptr+1);
return result; }
//Вызов:
strdel(str,strres);
std::cout << strdel(str,strres);
```

## 16. Параметры структуры. Пример

## 17. Классы памяти переменных. Примеры

```c++
extern int a; //внешняя переменная, которая доступна во всех местах программы
void foo(int a); //локальная переменная, которая перекрывает внешнюю переменную при работе процедуры
```

```c++
void counter() {
  static int count = 0; 
  cout << count++;
}
int main() {
  for (int i = 0; i < 10; ++i) {
    counter();
  }
  return 0;
}
// в данной программе выделение памяти для переменно count происходит один раз, и при каждом вызове функции происходит лишь обращение к ранее скомпилированной переменной.
```

## 18. Параметры-функции. Пример

Способ передать одну функцию в качестве аргумента
другой функции. Для этого нужно использовать
указатели на функции, которые хранят адреса функций в
памяти.

```c++
#include <iostream>
using namespace std;
// Тип для указателя на функцию, которая принимает два int и возвращает int
typedef int (*func) (int a, int b);
// Функция, которая вызывается в качестве параметра
int call_func (int a, int b) { return a + b; }
// Функция, которая принимает два int и указатель на функцию
void function (int a, int b, func f) {
int sum = f (a, b); // Вызываем функцию по указателю
cout << "Sum = " << sum << endl;
}
int main ()
{
function (5, 2, &call_func); // Передаем адрес функции call_func в качестве параметра
}
```

## 19. Правила, определяющие видимость переменных в функциях. Пример

## 20. Пространства имен. Пример

Пространства имен в с++ - это способ организовать код в логические группы и избежать конфликтов имен между разными функциями, классами,переменными и т.д. Пространство имен представляет собой блок кода, который имеет некоторое имя и содержит различные компоненты (функции,классы, константы и т/д.). Для доступа к компонентам пространства имен нужно использовать его имя с оператором :: (оператор области видимости).
Например:

```c++
// Определение пространства имен math
namespace math{
// Константа pi внутри пространства имен math
const double pi = 3.14;
// Функция square внутри пространства имен math
double square(double x) {
return x * x;
}
}
// Доступ к компонентам пространства имен math извне
double area = math::pi * math::square(5); // площадь круга с радиусом 5
```

Существуют два основных типа пространств имен:поименованные и непоименованные
Поименованные пространства имен имеют явное имя, которое
указывается после ключевого слова namespace. Поименованные
пространства имен могут быть вложенными друг в друга, то есть
одно пространство имен может содержать другое пространство
имен. Для доступа к вложенному пространству имен нужно
использовать имя родительского пространства имен с оператором ::.
Например:

```c++
// Определение пространства имен console
namespace console{
// Определение вложенного пространства имен messages
namespace messages {
// Константа hello внутри вложенного пространства имен messages
const std::string hello = "Hello world!";
// Функция print_hello внутри вложенного пространства имен messages
void print_hello(){
std::cout << hello << std::endl;
}
}
}
// Доступ к компонентам вложенного пространства имен messages извне
std::cout << console::messages::hello << std::endl; // выводит Hello world!
console::messages::print_hello(); // выводит Hello world!
```

Непоименованные пространства имен не имеют явного имени, а
обозначаются пустыми скобками после ключевого слова namespace.
Непоименованные пространства имен используются для
определения переменных или функций, которые должны быть видны
только в файле, где они объявлены, то есть иметь внутреннее
связывание. Это аналогично использованию ключевого слова static
для глобальных переменных или функций. Непоименованные
пространства имен не могут быть вложенными. Например:

```c++
// Определение непоименованного пространства имен
namespace
{
// Переменная x внутри непоименованного пространства имен
int x = 10;
// Функция print_x внутри непоименованного пространства имен
void print_x()
{
std::cout << x << std::endl;
}
}
// Доступ к компонентам непоименованного пространства имен извне
std::cout << x << std::endl; // ошибка: x не объявлен в этой области видимости
print_x(); // ошибка: print_x не объявлен в этой области видимости
// Для доступа к компонентам непоименованного пространства имен нужно использовать
оператор :: без имени
std::cout << ::x << std::endl; // выводит 10
::print_x(); // выводит 10
// Компоненты непоименованного пространства имен не видны в других файлах программы
```

## 21. Компоновка модулей С++. Защита от повторной компиляции. Пример

Компоновка модулей C++ — это процесс связывания разных
файлов реализации и заголовков в один исполняемый файл.
Компоновка модулей C++ может быть сложной и вызывать
различные ошибки, такие как неопределенные ссылки,
множественные определения или нарушения правил однократного
определения. Чтобы избежать этих ошибок, нужно соблюдать
некоторые правила и соглашения при организации кода на C++.
Одно из таких соглашений — это защита от повторной
компиляции (include guard). Защита от повторной компиляции
предотвращает повторное включение одного и того же файла
заголовка в одну единицу трансляции. Это может произойти, если
файл заголовка включает другой файл заголовка, который уже был
включен ранее. Повторное включение файла заголовка может
привести к множественным определениям переменных или функций,
которые нарушают правило однократного определения.
Защита от повторной компиляции обычно реализуется с помощью
директив препроцессора #ifndef, #define и #endif. Эти директивы
проверяют, определен ли некоторый макрос, который служит
уникальным идентификатором файла заголовка. Если макрос не
определен, то препроцессор включает содержимое файла заголовка
и определяет макрос. Если макрос уже определен, то препроцессор
пропускает содержимое файла заголовка.
Пример защиты от повторной компиляции:

```c++
// Файл header.h
// Проверяем, определен ли макрос HEADER_H
#ifndef HEADER_H
// Если нет, то определяем его
#define HEADER_H
// Здесь пишем содержимое файла заголовка
// Заканчиваем блок защиты от повторной компиляции
#endif
```

Таким образом, если файл header.h будет включен несколько раз в
одну единицу трансляции, то его содержимое будет скомпилировано
только один раз. Это ускоряет процесс компиляции и избегает
ошибок множественных определений.

## 22. Перегрузка функций. Пример

Перегрузка функций-способ написания функций с одинаковыми именами, но для разных наборов параметров.
При этом, компилятор определяет какаую функцию вызвать по типу парааметров и их кол-ву.

```c++
int foo(int a,int b);
int foo(string a, string b);
int main(){
    string s1="Hello";
    string s2="world!";
    foo(s1,s2)//вызов функции foo() для параметров-строк
}
```

## 23. Функции с параметрами по умолчанию. Пример

Функции с параметрами по умолчанию — это функции, которые могут быть вызваны с меньшим количеством аргументов, чем параметров. В этом случае для недостающих аргументов
используются значения по умолчанию, которые указываются при объявлении или определении функции.
Функции с параметрами по умолчанию позволяют писать более гибкий и удобный код, так как можно вызывать одну и ту же функцию с разными наборами аргументов в зависимости от ситуации.
Например, можно определить функцию print, которая принимает строку для вывода и символ для заполнения пробелов, но имеет значение по умолчанию для второго параметра.
Пример функции с параметрами по умолчанию:

```c++
#include <iostream>
#include <iomanip>
#include <string>
// Функция print принимает строку s и символ c
// Значение по умолчанию для c - пробел
void print(const string& s, char c = ' ')
{
// Выводим строку s с заполнением символом c
std::cout << std::setfill(c) << std::setw(20) << s << std::endl;
}
int main()
{
// Вызываем функцию print с двумя аргументами
print("Hello", '*'); // выводит ******Hello
}
```

При использовании функции со значениями по умолчанию наиболее часто изменяемые параметры указывают в начале списка параметров, так как изменять порядок их следования нельзя.

## 24. Текстовые файлы. Отличие от Delphi Pascal. Пример

>Если в Pascal можно было просто создать файловую переменную, свзяать ее с именем файла, и работать с ней с помощью стандартных команд, то в C++ для работы с файлами нужно подключить библиотеку `fstream`, создать объект класса `fstream`, и дальше вызывать его методы для работы с файлами.
>>Либо можно навернуть говна с работой с файлами в C-style.

```c++
#include <iostream>
#include <fstream>
#include <string>
using namespace std;
int main() {
ofstream f("test.txt"); // Создаем и открываем файл для записи
f << "Hello, world!" << endl; // Записываем строку в файл
f.close(); // Закрываем файл
ifstream f("test.txt"); // Открываем файл для чтения
string s; // Создаем переменную для хранения строки из файла
getline(f, s); // Читаем строку из файла в переменную s
cout << s << endl; // Выводим строку на экран
f.close(); // Закрываем файл
return 0;
}
```

## 25. Двоичные файлы. Отличие от Delphi Pascal. Пример

## 26. Определение класса, компоненты класса. Ограничение доступа. Пример

```
Класс-пользовательский тип данных, в которых хранятся поля, а также методы, которые могут работать с этими полями.
```

В С++ отличие между структурой и классом только в том, что в структуре по умолчанию все поля public, а в классе private.

```
Компоненты класса:

Внутренние(private) - доступны только методам класса,дружестевнным функциям и дружественным классам.

Публичные (public) - доступен всем методам в программе. Исключение - если класс потом унаследован от private класса родителя.

Защищенные(protected) - недоступен из любого метода в программе, если это не friend функция или не friend-класс. Также доступен в методах унаследованного класса, но не в его екземплярах.
```

Примеры:

```c++
//private
void inc(){ //дружественная функция
    A obj;
    obj.val++;
}

class A{
    private:
    int val=5;
    public:
    void getnum(){cout<<val;}
    friend void inc();
    friend class B;
}

class B{            //дружественный класс
    void method(){
        A object;
        object+=3; //нет ошибки, так как дружественный класс
    }
}

int main(){
    A myobj;
    myobj.val; //ошибка, т.к. поле private
    myobj.getnum(); //нет ошибки
    myobj.inc(); //нет ошибки, так как inc()-дружественная функция   
}
```

```c++
//public
void inc(){
    A obj;
    obj.val++;
}

class A{
    private:
    int val=5;
    public:
    void getnum(){cout<<val;}
    friend void inc();
}

class B : private A {}

int main(){
    A myobj;
    myobj.val; //нет ошибки
    myobj.getnum(); //нет ошибки
    myobj.inc(); //нет ошибки
    B few;
    few.val=3; //ошибка, так как наследование private
}
```

```c++
//protected
void inc(){ //дружественная функция
    A obj;
    obj.val++;
}

class A{
    private:
    int val=5;
    public:
    void getnum(){cout<<val;}
    friend void inc();
    friend class B;
}

class B{            //дружественный класс
    void method(){
        A object;
        object+=3; //нет ошибки, так как дружественный класс
    }
}

int main(){
    A myobj;
    myobj.val; //ошибка, т.к. поле protected
    myobj.getnum(); //нет ошибки
    myobj.inc(); //нет ошибки, так как inc()-дружественная функция
    
}
```

## 27. Инициализация полей при отсутствии конструктора. Пример

```
Если класс не имеет явного констуктора, то создается конструктор по умолчанию (конструктор без параметров).
Тогда, при создании объекта класса можно указыватьь значения его полей в фигурных скобках.
```

```c++
class Human{
    public:
    int age;
    string name;
}
int main{
    Human Second; //экземпляр без инициализации полей
    Human first{30,"Adam"}; //экземпляр с инициализацией полей
    cout<<first.age<<first.name;
}
```

```
Также, актуально использование специальных методов класса, которые инициализируют поля (сеттеры).
```

```c++
class Human{
    public:
    int age;
    string name;
    void Init(int myage, string myName){
        age=myage;
        name=myName;
    }
}
int main{
    Human Second; //экземпляр без инициализации полей
    Human first{30,"Adam"}; //экземпляр с инициализацией полей
    Second.Init(18,"Saucesamba"); //вызов set'тера для инициализации полей
    cout<<first.age<<first.name;
}
```

## 28. Конструкторы. Инициализация полей при наличии конструктора. Пример

```
Костурктор-специальная функция, которая имеет то же имя что и класс, и служит для инициализации полей класса.

В отличие от отдельного метода инициализации полей, конструктор не создаёт полей класса с мусорными значениями, а сразу записывает в них переданное значение.

Это эффективно по потреблению памяти, а также безопасно, если поля являются объектами другого класса.

```

```c++
//пример конструктора
class A{
private:
    int x;
    int y;
public: 
    A(int a,int b): x(a), y(b) {}; //коструктор с параметрами и списком инициализации
}
```

```
Если в классе явно не указан коструктор по умолчанию (default), или нет конструкторов с параметрами, то создается констурктор по умолчанию. 
Он может использоваться для выделения памяти под объект.
```

```c++
class A{
private:
    int x;
    int y;
public:
    A(){} = default;
    A(int a; int b): x(a),y(b) {};
    A(int a; int b=100):x(a),y(b);
}
int main(){
    A(); //констурктор без параметров-выделена память под объект
    A(100,200); //обычный коструктор
    A(50); //конструктор, у которого значение поля y по умолчанию
}
```

Также существуют кострукторы перемещения и копирующие конструкторы. Подробнее о них в билетах 40,41.

## 29. Деструкторы. Пример

```
Деструктор-специальная функци, которая вызывается для удаления объекта, или когда время жизни объекта заканчивается.
Конструктор не имеет параметров и списка инициализации.
Каждый класс имеет только 1 деструктор.
```

```
Когда вызывается?
1. Завершение работы программы
2. Завершение времени жизни временного объекта.
3. Освобождение памяти с помощью delete. 
```

```c++
class A{
private:
    int x;
public:
    A(int a): x(a){cout<<"Constructor"};
    //дестуктор 
    ~A(){
        delete x; //освобождаем память поля x.
    }
}
```

Деструктор также может быть вызван явно с помощью полного имени функции деструктора. Однако это не рекомендуется делать, так как это может привести к повторному вызову деструктора или неопределенному поведению.

## 30. Инициализация полей объектов при наличии и отсутствии конструктора. Пример

`Билеты 27+28.`

## 31. Простое и множественное наследование классов. Пример

```
Наследование — это способ организовывать иерархии классов. При этом класс-наследник приобретает поля и функции базового класса, модифицируя их область видимости.
```

```c++
//пример простого наследования+пример ограничения наследования.
class A{
protected:
    int x;
public:
    A(int a):x(a) {};
}
class B final:public A{ //не сможем унаследоваться от класса В
private:
    string str;
public:
    B(int a,string mystr) : A(a), str(mystr) {};
}
```

```c++
//пример множественного наследования
class A{ 
protected: 
    int n;
public: 
    A(int an): n(an) {}
};

class B{ 
protected: 
    int m;
public:
    B(int am): m(am) {}
};

class AB :public A, public B
{ 
    int l;
public:
    AB(int an, int am, int al) :A(an), B(am), l(al) {};
    void pp() {std::cout << n << ' ' << m << ' ' << l; }
};
int main()
{ 
  AB ab(3, 4, 5);
  ab.pp();
  return 0;
}
```

<img src="31 вопрос.png"/>

## 32. Наследование. Ограничение доступа при наследовании. Пример

Видимость компонентов класса при наследовании.
<img src="32 вопрос.png"/>

`Смотри первый пример из вопроса 31.`

Также можно запретить дальнейшее наследование от данного класса с помощью служебного слова final

## 33. Конструкторы и деструкторы производных классов. Пример

Конструкторы и деструкторы базового класса можно использовать в производном.

<img src="33 вопрос.png"/>

```
При объявлении объектов производного класса всегда вызывается конструктор базового класса, используемый для инициализации наследуемых полей.

Если в списке инициализации конструктора производного класса вызов конструктора базового класса есть, то вызывается он.

Если в списке инициализации конструктора производного класса вызов конструктора базового отсутствует, то автоматически вызывается конструктор базового класса без параметров!
```

`Смотри второй пример из билета 31`

## 34. Композиция. Пример

```
Композиция - это механизм, который позволяет создавать объекты, содержащие другие объекты в качестве своих частей. Это достигается путем включения одного класса в другой класс
в качестве его полей.

При композиции объект класса не может существовать без другого класса (жесткая привязка);
```

```c++
//тут должен быть пример компоиции
```

## 35. Наполнение. Пример

```
Агрегация / Наполнение - это отношение между объектами, при котором один объект является частью другого объекта и при этом может существовать независимо от него (не жесткое включение).
```

```c++
class num{
private:
    int x;
public:
    void setnum(int a) { x=a; };
    int getnum () {return x;}
}
class intmas{
private:
    num mas[10];
public:
    void initmas(){
        for (int i=0;i<10;i++)
        mas[i].setnum(i);
    }
    void printmas(){
        cout<<mas[i].getnum()<<" ";
    }
}
```

То есть число может существовать в независимости от массива чисел, и его также можно использовать с другими классами.

## 36. Полиморфное наследование. Простой полиморфизм. Пример

```
Простой полиморфизм - механизм переопределения методов базового класса при наследовании в производном классе 
```

```c++
class Dog{
public:
    virtual void Print() { // виртуальный метод, так как его будем переопределять.
        cout<<"Gaw-Gaw";
    };
}
class Cow: public Dog{
public:
    void Print() override { //перекрывающий метод print
        cout<<"Moo-Moo";
    }
}
```

Простой полиморфизм происходит на этапе компиляции программы (раннее связывание), т.е.
компилятор определяет тип объекта и вызывает соответствующую реализацию метода.

## 37. Полиморфное наследование. Сложный полиморфизм. Пример

```
Сложный полиморфизм - это механизм переопределения методов, используемый для создания иерархии классов в различной функциональностью. (чаще используется вместе с абстрактными классами).

В C++ нельзя создать объект абстрактного класса!* Это логично, потому что методы абстратных классов не имеют реализации и используются в других классах, в которых они переопределяются и имеют свой собственный код-реализацию.
```

```c++
class Animal{
public:
    virtual void print() = 0; //виртуальный абстрактный метод
}

class Cat : public Animal {
public:
    void print() override {
        cout<<"Meow";
    }
}

class Bird : public Animal {
public:
    void print() override {
        cout<<"Twit";
    }
}
```

Сложный полиморфизм реализуется с помощью сложного связывания, и используется когда:

1. Есть динамические поля.
2. Если наследуемый метод вызывает переопределенный метод.
3. Процедура с полиморфным объектом.

## 38. Статические компоненты классов. Пример

Статические поля в классах - это переменные, которые принадлежат классу в целом, а не
конкретному объекту класса. Они объявляются с помощью ключевого слова `static` .

`static` переменная является общей для всех объектов класса

```c++
class Balls{
public:
    static int count;   //статическая переменная, которая будет общая для всех объектов класса Balls
    string color;
    Balls(string mycolor):color(mycolor){};
    static void print() {cout<<count;}; //статический метод, общий для всех объектов класса Balls
}
int Balls::count=5; //обращение к пространству имён класса Balls, и запись значения в поле count
int main(){
    Balls ball1("red");
    Balls::print(); //обращение к пространству имен класса Balls и вызов статического метода.
}
```

Статические методы - это методы класса, определенные при помощи того же слова `static`

Статические методы не получают параметра `this`, потому что они не оперируют конкретным объектом класса, а работают на уровне класса в целом.

## 39. Особенности работы с динамическими объектами. Пример

Основные особенности работы с динамическими объектами в C++:

1. Создание динамических объектов происходит с помощью оператора `new`. Оператор `new` возвращает указатель на выделенную область памяти, которую необходимо освободить с помощью оператора `delete`.
2. Освобождение памяти, занятой динамическим объектом, происходит с помощью оператора `delete` . Если не освободить память, занятую динамическим объектом, это приведет к утечке памяти.
3. Освобождение динамической памяти, выделенной для полей класса, происходит внутри деструктора.

```c++
class MyClass{
private:
    int num;
public:
    MyClass() { cout << ”Constructor called” << endl;}
    MyClass(int numa): num(numa){};
    void Print() { cout << num << endl;}
    ~MyClass(){
        cout << ”Destructor called” << endl;
    }
    void init(int numa) {this−>num = numa;}
};
int main(){
    MyClass *obj = new MyClass(5); // Указатель на объект (выделение памяти)
    obj−>Print(); // Вызов метода через указатель
    delete obj; //освобождение памяти из-под объекта.

    MyClass *object = new MyClass[5]; // динамический массив из 5 объектов класса MyClass
    for (int i=0;i<5;i++){            // Инициализация 5 объектов
        object[i].init(i);
    }
    for (auto i = 0; i < 5; i++){
        object[i].Print();
    }
    delete[] object; // Пишем [] чтобы освободить память всего массива, а не его первого элемент
}
```

## 40. Правило Пяти. Конструктор перемещения и операция присваивания перемещением.Пример

Эти методы являются особыми, автоматически создаваемыми компилятором в случае отсутствия их явного объявления программистом.

```
Если класс или структура определяет один из следующих методов, то они должны явным образом определять все виды методов:
1. Копирующий конструктор.
2. Конструктор перемещения.
3. Оператор присваивания.
4. Оператор присваивания перемещением.
5. Деструктор - если не используются “умные указатели”.
```

<br>
Конструктор перемещения вызывается, если параметр - временный объект: 
ClassName(ClassName && ObjectName) {...}
</br>

<br>
Оператор присваивания перемещением вызывается, если присваиваемый объект - временный: 
ClassName ClassName::operator= (ClassName&& ObjectName) {...} 
</br>

<br>
Если объект имеет физический адрес (не является временным), а требует организовать вызов
конструктора перемещения или оператор присваивания перемещением, то используют функцию move()

ClassName && std :: move (ClassName & ObjectName)
</br>

```c++
using namespace std;
class Number{ 
 private: 
    int * pnum; 
 public: 

    Number(int Num):pnum(new int(Num)){     //конструктор 
      cout<<"New, Constructor"<<endl; 
    } 

    Number(const Number &R):pnum(new int(*R.pnum)){    //копирующий конструктор
      cout<<"New, Constructor copy"<<endl; 
    }   

    Number():pnum(nullptr){}                           //конструктор без параметров

    Number& operator=(const Number &R){                 //оператор присваивания
      if (pnum!=nullptr){delete pnum;cout<<"Free"<<endl;}
      pnum=new int(*R.pnum); 
      cout<<"New Operator= copy"<<endl; 
      return *this; 
    }

    ~Number(){                                          //деструктор
     if (pnum!=nullptr){delete pnum;cout<<"Free"<<endl;}
    cout<<"Destructor"<<endl; 
    } 

    Number(Number&& R):pnum(R.pnum){                        //конструктор перемещения 
      R.pnum=nullptr; cout<<"Constructor move"<<endl; 
    } 

    Number& operator=(Number&& R){                          //оператор перемещения
      if (pnum!=nullptr){ 
        delete pnum; cout<<"Free move"<<endl; 
    } 
     pnum=R.pnum; 
     R.pnum=nullptr; cout<<"Operator= move"<<endl; 
     return *this; 
   } 
};
Number f(int a,int b) {
  Number temp(a+b); 
  return Number(move(temp)); 
} 
int main() { 
  Number A(5); 
  Number B(A); 
  Number C(move(A)); 
  Number D(6); 
  D=move(A); 
  Number F=f(6,7); 
  return 0; 
}

```

`написать подробнее про переопрееление операций, и эти констуркры`

## 41. Объекты с динамическими полями. Копирующий конструктор. Пример

## 42. Дружественные функции, методы и классы. Пример

## 43. Переопределение операций. Пример

```
Переопределение операций - это возможность определить свою реализацию стандартных
операций для пользовательских типов данных, таких как классы.
```

Если не добавить собственную реализацию операций для пользовательских типов, то будет ошибка.

```c++
class A{
private:
    int x;
    int y;
public:
    A(){};                              //конструктор без параметров
    A(int a, int b) : x(a), y(b) {};    //конструктор
    A(A &obj){                          //копирующий конструктор
        x=obj.x; y=obj.y;
    };
    ~A();                               //деструктор
    A& A::operator=(A const &obj){      //оператор присваивания
      x=obj.x; y=obj.y;
      return *this;
    };
    A& A::operator+=(A &obj){           //переопределение оператора +=
      x+=obj.x; y+=obj.y; 
      return *this;
    }   
}
int main(){
    A point1(3,4);
    A point2(5,6);
    point1+=point2;   //point1 {8,10}
}
```

Некоторые правила:

1. Можно переопределять только операции, параметры которых – объекты.
2. Не разрешается переопределение: sizeof , ? : (тернарные операторы), # , ## , ::
(пространство имен), <класс> :: (область видимости)
3. При переопределении операций нельзя изменить ее приоритет и ассоциативность.

## 44. Шаблоны классов. Пример

Шаблон класса – обобщенное описание класса, содержащее параметры, позволяющие задавать типы используемых полей или других данных. Определяется с помощью слова `template`.

```c++
template <typename T> // Создание шаблона с произвольным типом
 class MyClass{
private:
    T value;
public:
    MyClass(T mvalue) : value(mvalue) {}; 
    void DataTypeSize(){
        cout << sizeof(value) << endl; // Выводит размер переменной в байтах
    }
 };

 int main() {
 int a = 5;
 MyClass<int> myclass(a);
 myclass.DataTypeSize(); // 4 размер int в байтах
 long long b = 10;
 MyClass<long long> myclass2(b);
 myclass2.DataTypeSize(); // 8 размер long long в байтах
 return 0;
}
```

## 45. Шаблоны функций. Пример

```c++
template <typename T> // Описание шаблона с общим типом T
T Sum(T a, T b) // Описание шаблонной функции
 {
 return a + b;
 }

int main(){
 cout << Sum(4, 10) << endl;
 cout << Sum(4.6, 9.5) << endl;
 return 0;
}
```

```c++
//пример передачи разных типов в функцию
template <typename T1, typename T2>
T1 Sum(T1 a, T2 b){
Copyright botva 66
return a + b;
}

int main(){
cout << Sum(4, 10.9) << endl;
return 0;
}
```

Шаблоны функций в C++ позволяют создавать обобщенный код, который может работать с
различными типами данных, НЕ требуя явного указания типа данных, потому что он определится автоматически при компиляции.

## 46. Организация библиотеки ввода/вывода С++. Операции извлечения и вставки. Пример

```
Операции сдвигов "<<", ">>"  в классах потоков переопределены для обозначения операций ввода-вывода с преобразованием к символьному виду или из него
```

```c++
#include <iostream>
using namespace std;
int main(){
    int age;
    cin>>age;
    cout<<"Your age: "<<age<<endl;
    return 0;
}
```
`Хз, есть ли смысл говорить в этом вопросе про флаги стандартной библиотеки iosream, но если надо - то напишу`

## 47. Организация контейнеров на классах. Пример диаграммы классов

## 48. Организация контейнеров на шаблонах. Пример диаграммы классов

## 49. Организация интерфейса с использованием виджетов Qt. Пример

~~`Ура, кринж вопросы`~~
Виджет в QT - это графический элемент интерфейса пользователя, который может быть размещен на окне приложения. Виджетами могут быть кнопки, поля ввода, метки, таблицы, графики и т.д.

```c++
 #include <QApplication>
 #include <QWidget>
 #include <QLabel>
 #include <QPushButton>

 int main(int argc, char *argv[]){

 QApplication app(argc, argv);
 QWidget *window = new QWidget;
 window−>setWindowTitle(”My App”);
 QLabel *label = new QLabel(”Hello, World!”, window);
 label−>setGeometry(50, 50, 200, 50);
 QPushButton *button = new QPushButton(”Click me!”, window);
 button−>setGeometry(50, 100, 200, 50);
 QObject::connect(button, &QPushButton::clicked, [=](){
 label−>setText(”Button clicked!”);
 });
 window−>show();
 return app.exec();
 }
```

## 50. Сигналы, слоты и события Qt. Пример

~~`Душно`~~

Сигналы, слоты и события являются основными механизмами взаимодействия между объектами в Qt.

1. `Сигналы` - это события, которые генерируются объектом при определенных условиях.
Они могут быть переданы другим объектам, называемым слотами, для выполнения определенных действий.
2. `Слоты` - это функции, которые вызываются при получении сигнала. Они могут использоваться для выполнения любых действий, включая изменение состояния объекта или
вызов других функций.
3. `События` - это действия, которые происходят в приложении, такие как нажатие клавиши или щелчок мыши. Они могут быть обработаны объектами, которые подписались на
определенные события.

```c++
//пример создания слота
public slots:
    void onButtonClicked();
```

```c++
//пример подключения сигнала к слоту
connect(ui−>pushButton, SIGNAL(clicked()), this, SLOT(onButtonClicked()));
```

```c++
//пример реализации слота
void MainWindow::onButtonClicked(){
ui−>label−>setText(”Hello, world!”);
}
```

## Ответы на вопросы Ивановой, которые она озвучивала на лекциях.

